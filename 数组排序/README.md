

## 先说几个名词

在开始之前，先介绍下排序算法的几个名词。

### 1. 排序的定义

对一序列对象根据某个关键字进行排序。

### 2. 对于评述算法优劣术语的说明

#### （1）稳定性

**稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；

**不稳定**：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面

#### （2）内排序、外排序

**内排序**：所有排序操作都在内存中完成；

**外排序**：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；

#### （3）时间、空间复杂度----什么是好算法，什么是坏算法

判断一个算法的好坏，一般从`执行时间`和`占用空间`来看,执行时间越短，占用的内存空间越小，那么它就是好的算法。对应的，我们常常用时间复杂度代表执行时间，空间复杂度代表占用的内存空间。

这里着重讲一下**时间复杂度**和**空间复杂度**

### 3. 时间复杂度

> 时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。

随着`n`的不断`增大`，时间复杂度不断`增大`，算法`花费时间`越多。 常见的时间复杂度有

- 常数阶`O(1)`
- 对数阶`O(log2 n)`
- 线性阶`O(n)`
- 线性对数阶`O(n log2 n)`
- 平方阶`O(n^2)`
- 立方阶`O(n^3)`
- k次方阶`O(n^K)`
- 指数阶`O(2^n)`

#### 计算方法

1. 选取相对增长最高的项
2. 最高项系数是都化为1
3. 若是常数的话用O(1)表示

举个例子：如f(n)=3*n^4+3n+300 则 O(n)=n^4

通常我们计算时间复杂度都是计算最坏情况。计算时间复杂度的要注意的几个点

- 如果算法的执行时间`不随n`的`增加`而`增长`，假如算法中有`上千条`语句，执行时间也不过是一个`较大的常数`。此类算法的时间复杂度是`O(1)`。 举例如下：代码执行100次，是一个常数，复杂度也是`O(1)`。

```js
    let x = 1;
    while (x <100) {
     x++;
    }

```

- 有`多个循环语`句时候，算法的时间复杂度是由`嵌套层数最多`的循环语句中`最内层`语句的方法决定的。举例如下：在下面for循环当中，`外层循环`每执行`一次`，`内层循环`要执行`n`次，执行次数是根据n所决定的，时间复杂度是`O(n^2)`。

```js
  for (i = 0; i < n; i++){
         for (j = 0; j < n; j++) {
             // ...code
         }
     }

```

- 循环不仅与`n`有关，还与执行循环`判断条件`有关。举例如下：在代码中，如果`arr[i]`不等于`1`的话，时间复杂度是O(n)。如果`arr[i]`等于`1`的话，循环不执行，时间复杂度是`O(0)`。

```js
    for(var i = 0; i<n && arr[i] !=1; i++) {
    // ...code
    }


```



### 4. 空间复杂度

> 空间复杂度是对一个算法在运行过程中临时占用存储空间的大小。

#### 计算方法：

1. 忽略常数，用O(1)表示
2. 递归算法的空间复杂度=(递归深度n)*(每次递归所要的辅助空间)

计算空间复杂度的简单几点

- 仅仅只复制单个变量，空间复杂度为O(1)。举例如下：空间复杂度为O(n) = O(1)。

```js
   let a = 1;
   let b = 2;
   let c = 3;
   console.log('输出a,b,c', a, b, c);

```

- 递归实现，调用fun函数，每次都创建1个变量k。调用n次，空间复杂度O(n*1) = O(n)。

```js
    function fun(n) {
       let k = 10;
       if (n == k) {
           return n;
       } else {
           return fun(++n)
       }
    }
```



## 先认识下排序算法（网上找的图）

网上搜索排序算法，基本都可以看见这两张图：

1. 算法对比：

   **n**: 数据规模
   **k**:“桶”的个数
   **In-place**: 占用常数内存，不占用额外内存
   **Out-place**: 占用额外内存

![inde](.\images\inde.png)

2. 算法分类：

   ![categories](.\images\categories.png)



接下来详细的介绍下这几个排序算法。图片也是来源于网络。  

## 1. 冒泡排序

### 思路

有N个数字的数组，进行N轮排序，在每一轮中，从前往后以此比较两两相邻的数字，每次比较后，都把大的往后放，一轮下来，最大的数会被推到数组最后。就好像气泡升至表面一样，冒泡排序因此得名。

![bubble](D:\github\xxcr\js-code-notes\数组排序\images\bubble.gif) 

### 代码实现

```js
function bubbleSort () => {
    
}
```













## 参考文献

1. [十大经典排序算法总结（JavaScript描述）](https://juejin.cn/post/6844903444365443080)
2.  [面试了十几个高级前端，竟然连（扁平数据结构转Tree）都写不出来](https://juejin.cn/post/6983904373508145189)
3. [优雅的 JavaScript 排序算法（ES6）](https://juejin.cn/post/6844903582328717325)
4. [排序图解：js排序算法实现](https://www.jianshu.com/p/7e6589306a27)
5. [十大经典排序算法(javascript实现)](https://www.xiabingbao.com/post/sort/javascript-10-sort.html)

