## 继承

1. 定义：继承是一个类从另一个类获取方法和属性的过程。

2. js的继承：复制父类的属性和方法来重写子类原型对象。

    > 记住这个概念，你会发现JS中的继承都是在实现这个目的，差异是它们的实现方式不同。

## 实现方式

1. [原型链继承](# 1. 原型链继承)
2. [借用构造函数继承](#2. 借用构造函数继承)
3. [组合继承](#3. 组合继承)

### 准备

既然要继承，首先需要一个父类，定义一个`Person` 父类：

```js

function Person (name) {
  this.name = name || 'xuxu' // 实例基本属性 (该属性，强调私有，不共享)
  this.like = ['eat'] // 私有，不共享

  this.say = function() { // 实例引用属性 (该属性，强调复用，需要共享)
    console.log('hello')
  }
}

Person.prototype.getInfo = function () { // 将需要复用、共享的方法定义在父类原型上
  console.log(this.name + this.sex)
}

```

### 1. 原型链继承

1. 核心：将父类的实例作为子类的原型

2. 构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。

3. 代码：

    ```js

    function p (sex) {
      this.sex = sex
    }

    p.prototype = new Person()

    let p1 = new p('man')
    let p2 = new p('woman')

    // 优点：父类的方法可以被复用，p1和p2共用同一个方法
    console.log(p1.say === p2.say) // true
    // 原型上的方法也可以
    console.log(p1.getInfo === p2.getInfo) // true
    console.log(p1.getInfo()) // xuxuman
    console.log(p2.getInfo()) // xuxuwoman

    // 缺点1：父类的引用数据类型被所有子类实例共享
    p1.link.push('sleep')
    console.log(p1.link) // ['eat', 'sleep']
    console.log(p2.link) // ['eat', 'sleep']

    ```

4. 优点：父类的方法可以被复用，原型上的方法也可以。

5. 缺点：
    -   父类的引用数据类型被所有子类实例共享。
    -   子类在实例化的时候不能给父类构造函数传参。

### 2. 借用构造函数继承

1. 使用父类的构造函数来增强子类实例，等同于复制父类的实例给子类（不使用原型）。

2. 借用构造函数实现继承解决了原型链继承的 2 个问题：引用类型共享问题以及传参问题。
但原型链继承的优点也变成它的缺点。

3. 代码：

    ```js

    function p(name, sex) {
      Person.call(this, name)  // 核心
      this.sex = sex
    }

    let p1 = new p('小红', 'man')
    let p2 = new p('小明', 'woman ')

    // 优点1：可以向父类构造函数传参数
    console.log(p.name, p.name) // 小红， 小明

    // 优点2：子类实例不共享父类构造函数的引用属性
    p1.like.push('sleep')
    console.log(p1.like,p2.like)// ['eat', 'sleep'] ['eat']

    // 缺点1：方法不能复用,每次创建子类实例都要创建一遍方法
    console.log(p1.say === p2.say) // false (说明，p1和p2 的say方法是独立，不是共享的)

    // 缺点2：不能继承父类原型上的方法
    Person.prototype.walk = function () {   // 在父类的原型对象上定义一个walk方法。
      console.log('我会走路')
    }
    p1.walk  // undefined (说明实例，不能获得父类原型上的方法)

    ```

4. 优点：和原型链继承完全反过来。
    -   可以向父类构造函数传参数。
    -   子类实例不共享父类构造函数的引用属性。

5. 缺点：
    -   方法不能复用；由于方法必须定义在构造函数中，所以会导致每次创建子类实例都会创建一遍方法。
    -   不能继承父类原型上的方法，只能继承父类的实例属性和方法。

### 3. 组合继承

1. 通过调用父类构造函数，继承父类的属性并保留传参的优点；然后通过将父类实例作为子类原型，实现函数复用。

2. 代码：

    ```js

    function p(name, sex) {
      Person.call(this, name)  // 核心  第二次
      this.sex = sex
    }

    p.prototype = new Person() // 核心  第一次
    // 修复构造函数的指向
    p.prototype.constructor = p
    
    let p1 = new p('小红', 'man')
    let p2 = new p('小明', 'woman ')

    // 优点1：可以向父类构造函数传参数
    console.log(p.name, p.name) // 小红， 小明

    // 优点2：子类实例不共享父类构造函数的引用属性
    p1.like.push('sleep')
    console.log(p1.like,p2.like)// ['eat', 'sleep'] ['eat']

    // 优点3：父类原型上的方法可以被复用
    console.log(p1.getInfo === p2.getInfo) // true

    ```

3. 注意：p.prototype 指向的是Person 的实例，导致 p.prototype.constructor === Person。这就需要将constructor 指向子类的构造函数p。

4. 优点：
    -   保留构造函数的优点：1. 可以向父类构造函数传参数。2. 子类实例不共享父类构造函数的引用属性。
    -   保留原型链的优点：父类的实例方法定义在父类的原型对象上，可以实现方法复用。

5. 缺点：两次调用父类的构造函数，存在多余的一份父类的实例属性。
    -   第一次执行：`Person.call(this, name)` p 调用了Person 拷贝一份父类实例属性，作为子类的实例属性。
    -   第二次执行：`p.prototype = new Person()` 创建父类实例作为子类原型。
    -   第二次执行完后，父类实例就又有了一份实例属性，但这份会被第一次拷贝来的实例属性屏蔽掉，所以多余。

### 4. 原型式继承
### 5. 寄生式继承
### 6. 寄生组合继承
### 7. ES6 Class extends

## 参考文献

1. [JavaScript深入之继承的多种方式和优缺点](https://github.com/mqyqingfeng/Blog/issues/16)
2. [JavaScript常用八种继承方案](https://juejin.cn/post/6844903696111763470)
3. [一篇文章理解JS继承——原型链/构造函数/组合/原型式/寄生式/寄生组合/Class extends](https://segmentfault.com/a/1190000015727237)
4. [js继承、构造函数继承、原型链继承、组合继承、组合继承优化、寄生组合继承）](https://segmentfault.com/a/1190000015216289)
