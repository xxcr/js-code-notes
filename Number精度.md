
-   所以一个数字：
    1. 第0位：符号位，0表示正数，1表示负数(s)
    2. 第1位到第11位：11位，储存指数部分（e）
    3. 第12位到第63位：52位储存小数部分（即有效数字）f
-   __js最大安全数是 Number.MAX_SAFE_INTEGER == Math.pow(2,53) - 1__，而不是Math.pow(2,52) - 1
    因为：尾数部分f在规约形式下第一位默认为1，省略不写

##### 0.1 + 0.2 !== 0.3 
先按照IEEE 754转成相应的二进制，然后对阶运算，所以 __精度损失可能出现在 进制转化 和 对阶运算 过程中__
1. 十进制转二进制：
  -   整数转二进制：除二取余，然后倒序排列，高位补零。
      > 2为例： 2 / 2 = 1 --- 0    1 / 2 = 0 --- 1 到着排序为10
  -   小数转换为二进制的方法：对小数点以后的数乘以2，取结果的整数部分（不是1就是0喽），然后再用小数部分再乘以2，再取结果的整数部分……以此类推，直到小 数部分为0或者位数已经够了就OK了。
      > 0.1: 0.1 * 2 = 0.2 --- 0     0.2 * 2 = 0.4 --- 0    0.4 * 2 = 0.8 --- 0    0.8 * 2 = __1.6__ --- __1__    __0.6__ * 2 = 1.2 --- 1
  -   0.1 和 0.2 转换成二进制
      ```js
      0.1 -> 0.0001100110011001...(无限循环)
      0.2 -> 0.0011001100110011...(无限循环)
      ```
      由于IEEE 754尾数位数限制，需要将后面多余的位截掉，精度丢失

2. 对阶运算（小数点位置对齐）